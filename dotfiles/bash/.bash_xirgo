# .bashrc
[ -f ~/.fzf.bash ] && source ~/.fzf.bash

if type rg &> /dev/null; then
    export FZF_DEFAULT_COMMAND='rg --files --glob "!.git/*"'
    export FZF_DEFAULT_OPTS='-m --height 50% --border'
fi

export LD_LIBRARY_PATH="/usr/local/lib"

# AWS stuff
source ~/.bash_aws
# Xirgo stuff
source ~/.bash_xirgo

export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion

export PATH=$PATH:/mnt/c/_Git/ccls/Release/
export PATH=$PATH:/mnt/c/win32yank-x64/
source ~/.tldr.complete

#eval "$(starship init bash)"
#export STARSHIP_CONFIG=~/.starship/config.toml
cd /mnt/c/_Git
# .bash_aws
#!/bin/bash

# Functions Available:
# presign
# thing
# ota
# job
# status

# Examples:
## Presign an existing S3 resource and put the link in the clipboard.
## presign best_firmware.x00

## Change thing name (if you don't want to edit the default value in this file)
## thing XT3562-999

## Queue up ota job with firmware in your current directory or S3 bucket.
## ota best_firmware.x00 1

## Queue up regular job. (!cp:9,3)
## job cp 9 3

## Get status of previously executed job.
## status

# Aliases
alias presign='aws_presign'
alias thing='aws_thing'
alias ota='aws_ota'
alias job='aws_job'
alias status='aws_status'

# Variables
export AWS_PYTHON3="python3"                                             # python3 executable
export AWS_S3_BUCKET="ltem"                                              # S3 bucket name
export AWS_S3_PRESIGN="/mnt/c/_Git/utils/aws_presign.py"                 # presign python script
#export AWS_ARN="arn:aws:iot:us-west-2:011929418200:thing/"               # Amazon resource name (excluding thing name)
export AWS_ARN="arn:aws:iot:us-west-2:011929418200:thing/"
#export AWS_THING="XT3562-55"                                             # Thing name (default)
#export AWS_THING="XT2469-203500053"
export AWS_THING="XT2594-212614822"
export AWS_JOB_ID=-1                                                     # Most recent job id generated.

if [ $(which aws) != "/usr/bin/aws" ]; then
    echo "Please install and configure AWS CLI before trying to use AWS functions."
fi

# Presign specified firmware image and copy the link to the clipboard.
#
# @param[in] Resource  Artifact located in configured S3 bucket.
function aws_presign() {
    if [ "$#" -ne 1 ]; then
        echo "Usage: (Generate presigned link based on S3 resource, copy link to clipboard.)"
        echo
        echo "          presign <Resource>"
        echo
        echo "       <Resource>: Artifact located in configured S3 bucket."
        return 1
    fi

    ${AWS_PYTHON3} ${AWS_S3_PRESIGN} ${AWS_S3_BUCKET} ${1} us-east-1 129600 443 | clip.exe
}

# Changes default Thing Name used by 'ota_helper', 'job_helper', and 'job_status'.
function aws_thing() {
    export AWS_THING=${1}
}

# Loads firmware on S3 bucket. Generates presigned link. Creates OTA job using presigned link.
# Call this function in the directory where your firmware image is.
#
# @param[in] Firmware     Firmware Image File Name
# @param[in] Update Type  Type of update to be performed. (Boot, Main, Whopper, Cell, ect)
function aws_ota() {
    if [ "$#" -ne 2 ]; then
        echo "Usage: (Load Firmware to S3, generate presigned link, create job to OTA firmware to device.)"
        echo
        echo "              ota <Firmware> <Update_Type>"
        echo
        echo "       <Firmware>: Firmware Image File Name (Must be in current directory.)"
        echo "    <Update Type>: Type of update to be performed. (Boot, Main, Whopper, Cell, ect)"
        return 1
    fi

    # Load firmare onto S3 bucket. (if it exists)
    if [ -f ${1} ]; then
        aws s3 cp ${1} s3://${AWS_S3_BUCKET}
    else
        echo "Firmware not found. Is it already hosted on S3?"

        read -p '(y/n): ' response

        if [ "${response}" != "y" ]; then
            echo "Please navigate to the directory where the firmware image is located, or host it on S3."
            return 1
        fi
    fi

    # Generate presigned link for firmware.
    URL=$(${AWS_PYTHON3} ${AWS_S3_PRESIGN} ${AWS_S3_BUCKET} ${1} us-east-1 129600 443)

    # Create job using presigned link.
    job uf ${2} ${URL}
}

# Creates Job using arguments to build the job document.
#
# @param[in] Command       Command string without '!'. Ex: cp uf cs ip is
# @param[in] [Index]       First index supplied to commnand.
# @param[in] [Argument(s)] Rest of the string supplied to the command.
function aws_job() {
    if [ "$#" -lt 1 ]; then
        echo "Usage: (Creates Job using parameters passed in.)"
        echo
        echo "              job <Command> [<Index>] [<Argument(s)>]"
        echo
        echo "       <Command> : Command string without '!'. Ex: cp uf cs ip is"
        echo "       [<Index>] : First index supplied to commnand."
        echo " [<Argument(s)>] : Rest of the string supplied to the command."
        return 1
    fi

    ID=${RANDOM}${RANDOM}
    aws iot create-job --job-id ${ID} --targets ${AWS_ARN}${AWS_THING} --document '{"!'${1}'":["'${2}'","'${3}'"]}'
    #aws iot create-job --job-id ${ID} --targets ${AWS_ARN}${AWS_THING} --document '{"@'${1}'":["'${2}'","'${3}'"]}'

    # Export job ID for status checking.
    export AWS_JOB_ID=${ID}
}

# Describes job execution using the stored Thing and most recently executed Job initiated by 'job_helper' or 'ota_helper'.
function aws_status() {
    if [ ${AWS_JOB_ID} -eq -1 ]; then
        echo
        echo "    No job id saved. Please execute a job using 'job_helper' or 'ota_helper'."
        echo "    Alternatively, you can export your job id to JOB_ID"
        echo
        return 1
    fi

    aws iot describe-job-execution --thing-name ${AWS_THING} --job-id ${AWS_JOB_ID}
}

# Put someting in bucket :)
function aws_bucket() {
    # if file exists and is encrypted bin
    echo ${1}
    if [ -f ${1} ] && [ ${1: -4} == ".x00" ]; then
        echo "~ENCRYPTION DETECTED~"
        aws s3 cp ${1} s3://${AWS_S3_BUCKET} --acl public-read
        echo "~YOUR SHIZ IS IN THE BUCKET~"
    fi
}
# .bash_xirgo

#!/bin/bash

# Variables
## Directories
### My Git dir
export REPOS_DIR="/mnt/c/_Git"
### My user dir
export USER_DIR="/mnt/c/Users/kovervig"
### My reanimate dir
export REAN_DIR="/mnt/c/_Git/reanimate"
### My testboy dir
export TESTBOY_DIR="/mnt/c/_Git/testboy"
### Falcon output dir
export FALCON_OUTPUT="/mnt/c/_Git/reanimate/build/falcon_output"
### Download dir
export DL_DIR="/mnt/c/Users/kovervig/Downloads"
## Komodo
export KOMODO_DEV_PORT="/dev/ttyS16"
## Testboy cert and key
export TB_USER_CERT="/mnt/c/_Git/testboy/certs/general_user_crt.pem"
export TB_USER_KEY="/mnt/c/_Git/testboy/certs/general_user_key.pem"

#Komodo 
export KOMODO_SOURCE="/mnt/c/_Git/reanimate"
export KOMODO_TOOLCHAIN="/mnt/c/_Git/LLVM/4.0.3/LNX"

# Get win_home_dir's
# C:\Users\kovervig
WIN_HOME_RAW="$(cmd.exe /c "<nul set /p=%UserProfile%" 2>/dev/null)"
# /mnt/c/Users/kovervig
WIN_HOME="$(wslpath $WIN_HOME_RAW)"
# path to reanimate

# Functions
## Reanimate

# Build fw for specified platform
#
# @param[in] Platform. (komodo/1185, castanet/1168, castanet_boot, harpsichord/1188,
# harpsichord_boot, viola/1179)
function build() {
    if [ "$#" -ne 1 ]; then
        echo "Usage: (Build fw for specified platform)"
        echo
        echo "          build <Platform>"
        echo
        echo "       <Platform>: (komodo, castanet, castanet_boot, harpsichord, harpsichord_boot, viola)"
        return 1
    fi
    dir=`pwd`
    case $1 in
        castanet | castanet_boot | harpsichord | harpsichord_boot | viola)
            cd ${REAN_DIR}
            cmd.exe /c "C:\\Program Files (x86)\\IAR Systems\\Embedded Workbench 8.2\\common\\bin\\IarBuild.exe" ewp/$1.ewp -make engineering -parallel 8
            ;;
        komodo)
            cd ${REAN_DIR}
            rm -rf build/komodo
            make -f ewp/komodo.make -j
            ;;
        *)
            echo -n "unknown platform"
        esac
    cd $dir
}

# Build a whopper using the yourway script in build/tools for a specific sha
#
# @param[in] Platform. (castanet, harpsichord)
# @param[in] Sha.

function yourway() {
    if [ "$#" -ne 2 ]; then
        echo "Usage: (Build whopper specified platform)"
        echo
        echo "          yourway <Platform> <Sha>"
        echo
        echo "       <Platform>: (castanet, harpsichord)"
        echo "       <Sha>: commit sha for fw you want to build"
        return 1
    fi
    dir=`pwd`
    cd ${REAN_DIR}/build/tools/
    mv whopper whopper.exe
    cd ${REAN_DIR}/tools/
    bash yourway.sh ${1} ${2} .
    cd ${REAN_DIR}/build/tools/
    mv whopper.exe whopper
    cd $dir
}

function punch() {
    dir=`pwd`
    cd /mnt/c/_Git/scripts
    ./falcon_funcs.sh
    cd $dir

}

# Falcon pawnch your current changes out to the build server and receive a bin in the local directory
#
# @param[in] Platform (castanet, 1168, ...)
# @param[in] boot bin --optional default to whopper for platforms with both
#
# Useage:
# pawnch 1168
# pawnch 1168 main x00
# pawnch 1168 BOOT BIN
# pawnch 1185

function pawnch() {
    dir=$(pwd)
    cd ${REAN_DIR}

    platform=""
    fw_type=""
    file_type=""
    build_str=""
    cust_app=false
    if [[ ${1,,} == "-h" ]] || [[ ${1,,} == "-help" ]] ; then
        echo "Usage:"
        echo
        echo "pawnch 1168"
        echo pawnch 1168 main x00
        echo pawnch 1168 BOOT BIN
    fi
   if [[ ${1,,} == "cie" ]] || [[ ${1,,} == "castanet" ]] || [[ ${1,,} == "1168" ]]
        then platform="castanet"
    elif [[ ${1,,} == "wx" ]] || [[ ${1,,} == "komodo" ]] || [[ ${1,,} == "1185" ]]
        then platform="ocarina"
             cust_app=true
    elif [[ ${1,,} == "khlui_na" ]] || [[ ${1,,} == "khlui_eu" ]]
        then platform=${1,,}
             cust_app=true
    elif [[ ${1,,} == "khlui_ii" ]] || [[ ${1,,} == "khlui2" ]] || [[ ${1,,} == "k2" ]]
        then platform="khlui2"
             cust_app=true
    elif [[ ${1,,} == "bhph" ]] || [[ ${1,,} == "1189" ]]
        then platform="bhph"
             cust_app=true
    elif [[ ${1,,} == "harp" ]] || [[ ${1,,} == "harpsichord" ]] || [[ ${1,,} == "1188" ]]
        then platform="harpsichord"
    elif [[ ${1,,} == "harm" ]] || [[ ${1,,} == "harmoneon" ]] || [[ ${1,,} == "1177" ]]
        then platform="harmoneon"
    elif [[ ${1,,} == "vio" ]] || [[ ${1,,} == "viola" ]] || [[ ${1,,} == "1179" ]]
        then platform="viola"
    else 
        echo "Invalid platform provided: ${1}"
        return
    fi

    if [[ ${2,,} == "main" ]] || [[ ${2,,} == "boot" ]] || [[ ${2,,} == "whopper" ]]
        then fw_type=${2,,}
    elif [[ -z "${2}" ]]
        then echo "No input for argument 2 (fw_type)"
    else
        echo "Invalid fw type: ${2}"
    fi

    if [[ ${3,,} == "x00" ]] || [[ ${3,,} == "bin" ]]
        then file_type=${3,,}
    elif [[ -z "${3}" ]]
        then echo "No input for argument 3 (file_type)"
    else
        echo "Invalid file type: ${3}"
        return
    fi

    if [[ ! -z "${fw_type}" ]] && [[ ! -z "${file_type}" ]]; then
        if [[ ${2,,} != "whopper" ]]; then
            build_str="${platform}/${fw_type}/${file_type}"
        else
            build_str="${platform}/${file_type}"
        fi
    else
        file_type="bin"
        build_str="${platform}"
    fi

    echo
    echo "Getting: ${build_str}"
    echo

    ${TESTBOY_DIR}/utils/falcon.sh ${build_str}

    file=`ls *.${file_type}` # Get name of produced binary to rename the falcon.patch as well as could be used for error checking
    myfilesize=$(wc -c "falcon.patch" | awk '{print $1}')
    if [[ ${myfilesize} != 0 ]]; then
        mv "falcon.patch" ${FALCON_OUTPUT}/${file}_falcon.patch
    else
        rm -f "falcon.patch"
    fi

    if [[ ${cust_app} = true ]]; then
        cp *.${file_type} "${FALCON_OUTPUT}/cust_app_update.bin"
        echo "Copied to cust_app_update.bin"
    fi
    mv *.${file_type} ${FALCON_OUTPUT}

    cd ${dir}    mv *.${file_type} ${FALCON_OUTPUT}
    #cd ${FALCON_OUTPUT}
    #explorer.exe .
    cd ${dir}
}

# Start an MQTT server
#
# @param[in] Platform or Platform and DSN
# 
function server() {
    dir=`pwd`
    if [ "$#" -ne 1 ]; then
        cd ${REPOS_DIR}/utils/Zubie/Py3
        CONFIG=py3config_all_devices.txt
        python3 Py3_MQTT_Client.py -f $CONFIG -d debug
    fi
    cd $dir
}
## WX
# Start an MQTT server
#
# @param[in] Platform or Platform and DSN
# 
function wx_server() {
    dir=`pwd`
    if [ "$#" -ne 1 ]; then
        cd ${REPOS_DIR}/utils/Zubie/Py3
        CONFIG=py3config_wx.txt
        python3 Py3_MQTT_Client.py -f $CONFIG -d debug
    fi
    cd $dir
}

function komodo_upload() {
    dir=`pwd`
    cd /mnt/c/_Git/scripts
    ./komodo_upload.sh ${KOMODO_DEV_PORT}
    cd $dir
}

## Config Files

function bashrc() {
    nvim ~/.bashrc
}

function vimrc() {
    nvim ~/.vimrc
}

function termrc() {
    nvim ${USER_DIR}/AppData/Local/Packages/Microsoft.WindowsTerminal_8wekyb3d8bbwe/LocalState/settings.json
}
## Open Windows File explorer Shortcuts

## Directory Shortcuts

function rean() {
    cd ${REAN_DIR}
}

function tb() {
    cd ${TESTBOY_DIR}
}

function tbc() {
    cd ${REPOS_DIR}/testboy_cases
}

function dl() {
    cd ${DL_DIR}
}

# Encrypt a binary
function encrypt() {
    dir=$(pwd)
    tool_dir="${REAN_DIR}/tools"
    cp ${1} ${tool_dir}
    cd ${tool_dir}
    cmd.exe /c mkpse.exe C:\\_Git\\reanimate\\tools\\${1}
    result=$(echo "${1}" | sed "s/.bin/.x00/") # replace .bin with .x00 so we can copy it back to initial directory
    cp ${result} ${dir}
    cd ${dir}
}

# simcom acts as a serial passthrough for simulator commands
function sim() {
    simcom -p -s "/mnt/c/VBUS SIM/j2534 neo sim 7_10_6_1.exe" -a 127.0.0.1:65355 -l /dev/null
}
